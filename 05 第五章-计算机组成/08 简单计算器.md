# 简单计算机
> 引入一台简单（非真实）的计算机：  
> ![](5.8-pictures/简单计算机的组成.png)

## 5.8.1 CPU

1. 数据寄存器

> 16个16位的数据寄存器，地址为(0,1,2,......,F)16  
> 称他们为：R0~R15

2. 控制单元

> 具有电路，控制ALU的操作、对内存的读取和对I/O子系统的存钱  
> 有两个专用的寄存器：程序计数器和指令寄存器  
> 程序计数器（PC）只有8位，保存的是下一条将被执行的指令的踪迹  
> PC的内容指向含有下一条程序指令的主存的存储单元的地址  
> 每个机器周期后PC自动加1，指向下一条程序指令  
> 指令寄存器（IR）含有16位，是当前周期译码的指令


![](5.8-pictures/简单计算机的组成.png)
## 输入/输出子系统  

> 简单计算机有一个非常原始的输入/输出子系统  
> 由一个键盘和一台监视器组成  
> 虽然图中用分开的盒子表示键盘和监视器，但是子系统是内存地址方式的一部分  
> 这些设备有内存映射地址  
> 假定键盘和监视器（分别只做输入和输出设备）像内存单元一样，地址分别为（FE）16和（FF）16，他们就像16位的寄存器，作为内存单元与CPU进行交互  
> 把数据从外界传输到CPU或反之

## 指令集

> 简单计算机有16条指令集合的能力，但我们只能用这些指令中的14条  
> 每条指令由两部分构成：操作码和操作数  
> 操作码：指明在操作数上执行的操作的类型  
> 每条指令由16位组成，被分成4个4位的域  
> 最左边的域含有操作码  
> 其他三个域含有操作数或操作数的地址  
> 如下图示：  
> ![](5.8-pictures/格式和不同指令类型.png)  
> ***
> 指令列如下表，注意，并不是每条指令都要三个操作数，任何不需要的操作数域被填以0，例如停机指令的所有三个操作数域、传送指令和NOT指令的最后一个域都被填以（0）16；还要注意，寄存器地址是用单个16进制数来表示的，所以只要一个域，而内存单元是用两个16进制数来表示的，所有要用两个域  
> ![](5.8-pictures/简单计算机的指令表.png)　　
> 整数相加：ADDI　　
> 浮点数相加：ADDF　　
> 之前设置键盘地址为（FE）16，若以其作为LOAD指令的第二个操作数，简单计算机可以从键盘取得输入　　
> 同理（FF）16作为STORE指令的第二个操作数，简单计算机可以发送输出到监视器　　
> 如果ROTATE指令的第三个操作数是0，则指令把R中的二进制位模式向右循环位移n个位置，如果是1则左移  
> 加1：INC  
> 减1：DEC  


## 5.8.3处理指令  

> 周期：取指令、译码、执行  
> 取指令：其地址由PC决定的指令从内存中得到被装入IR中，PC+1指向下一条指令  
> 译码：IR中的指令被译码，所需操作数从寄存器或内存中取得  
> 执行：指令执行，结果放入合适的内存单元或寄存器中  
> 一旦第三阶段结束，控制单元又开始新的周期，而现在的pc是指向下一条指令的，处理过程一直继续直到CPU遇到HALT指令

> 一个例子：  
> 让我们显示简单计算机如何进行整数A和B的相加的，创建的结果为C。假定整数是二进制补码格式。在数学上，这个操作表示为：  
> 								C=A+B  
> 为了用简单计算机解决这个问题，有必要把前面两个整数存放在寄存器中（例如R0和R1操作的结果存放在第三个寄存器中（例如R2).ALU只能操作那些存储在CPU数据寄存器中的数据。但是，大多数计算机（包括简单的计算机）在CPU中只有有限的寄存器。如果数据项的数量很大，并且它们在程序执行过程中应该保留在计算机中，比较好的方法是把它们存储在内存中，临时地把它们调人寄存器中。这样我们假定前两个整数存储在内存单元（40)16 和 (41)16 结果应该被存储在内存单元（42)16 中。这就意味着两个整数需要被调人CPU中，结果需要被存储在内存中。因此，完成这个简单加法的简单程序需要5条指令，显示如下:  
> 1) 把内存 M40 的内容装入寄存器R0 (R0<---M40).  
> 2）把内存M41的内容装人寄存器R1(R1<----M41).  
> 3）相加Ro和R1的内容，结果放入R2中(R2<—R0+R1).  
> 4）把R2的内容存人M42中(M42<—R2).  
> 5）停机。  
> ![](5.8-pictures/简单例子.png)


## 5.8.6存储程序和数据  

> 为了遵循冯-诺依曼模型，需要把程序和数据存储在内存中,从内存单元（00）16到（04）16存储5行程序  
> 数据也需要被存储在40，41和42（16进制）中  

## 5.8.7指令周期  
> 每条指令使用一个指令周期  
> 五条指令需要五个指令周期  
> 每个周期由三个步骤：取指令，译码，指向  
> 假如现在需要相加161+254=415（16进制分别为：00A1，00FE，019F)  
> ***
> 周期1  
> ![](5.8-pictures/周期１.png)
> ***  
> 周期2  
> ![](5.8-pictures/周期２.png)
> ***  
> 周期3  
> ![](5.8-pictures/周期３　.png)
> ***  
> 周期4  
> ![](5.8-pictures/周期４.png)
> ***
> 周期5  
> ![](5.8-pictures/周期５.png)